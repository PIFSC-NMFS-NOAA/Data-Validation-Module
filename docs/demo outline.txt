Feel free to stop me and ask questions:

Overview:
The Data Validation Module (DVM) was developed to provide a framework to validate data entered in a given Oracle database based on flexible data validation criteria that can be developed and implemented in Oracle Views by a data manager/developer without requiring application development skills.  A series of data QC Views can be developed to identify problematic values in the database and implemented in the framework to allow each validation rule to be evaluated on the given Data Stream.

Flexibility was a core design principle when I was developing this solution over the last couple months

DB Diagram Overview
	Flexible data model allows users to define their own issue severity types, issue resolution types, issue types (these are the actual validation criteria), issues (the actual instances of validation issues), and data streams (this is where the parent tables are defined)
	Parent tables are the parent records that will be evaluated as well as all relevant child records (e.g. fish REA transect, coral belt transect, cruise, etc.)

	All objects have a DVM_ prefix to help logically separate it from other objects in the DB

	This module was recently upgraded using the centralized cruise database

	Cruise data model overview is:
		Cruise has multiple cruise legs and multiple attributes, cruise legs have multiple attributes.  In this scenario the "parent table"

GitLab URL is available in documentation linked in the forum post as well as the Data Enterprise Google Site
	_ since we're talking about this please let other software developers in your divisions/programs know about the Google Site, I regularly update it with resources

GitLab interface (documentation is in MD format except for spreadsheets)
	Click on the main documentation link and give a brief overview of the documentation including the links
		The DVM requires two different modules (VCM handles version control for the DB and DB Logging Module allows DVM actions to be logged in the DB for troubleshooting/auditing purposes)
		The DB Module Packager project is going to be updated soon to include the DVM so folks can easily install them using two scripts (should be completed by the end of the week)
			In preparation for installing on an ESD database it would be helpful to get a database script together to install the ESD database or subset of the database in a given schema so it can be sandboxed and used as a test platform for implementing the DVM.  We can talk more about this later but it would require there to be a SQL script that instantiates the DB on a blank schema (recommend VCM for this)

How to define a QC rule (open the How to document)
	Show the QC Criteria template (blank and ready to use)
	Show the QC Criteria example from the cruise DB
		Show how the data streams were defined (data stream info including parent table - Cruise)
 		Show how the severity is defined (the DVM is installed with two severity type values but this can be expanded)
		Name the QC view (recommend it to have a _QC prefix along with whatever other prefix is defined in the data set
		Define the Field Name (this is the field that will be checked to determine if the given validation issue exists for the given parent record).  Calculated field I will show you an example when we look at the example view definitions
		Issue Type Description is a general description of the error
		Validation Issue Template (each placeholder defined in brackets will be replaced by the runtime view value to provide context to the user)
		Application URL template (each placeholder will be replaced by the runtime view value to construct the application URL - for APEX APP_ID and APP_SESSION are left alone to allow users to generate APEX application URLs using the API)
		Last three columns generate DML to insert the DVM configuration into the DB (recommended to save the output to a SQL file so it can be easily loaded in a given instance)

	How to define the view (recommended to group related/feasible validation criteria into the same views - e.g. record-level validation or aggregate validation)
		Show the Data QC View example on the bottom and show how the formulas are setup and which fields are included (primary key field, other informational fields - cruise name, etc.)
		Calculated fields indicate if the validation issue exists (Y) or not (N) - look at INV_CRUISE_NAME_YN field and how it is constructed, each criteria must also be included in the WHERE clause to filter out cases where there are no validation issues for a given parent table
		Flexible approach that allows database developers/data managers to define their own query logic
		_ Still need clean this up a bit, just realized that the highlight did not work in the code view but that makes sense

How to register into the DVM
	execute the data QC view DDL as well as the DVM DML that was generated by the spreadsheet

How to verify all of the placeholders for all validation criteria exist in the corresponding view (there is a view for that: DVM_QC_MSG_MISS_FIELDS_V)

Configure Parent table
	Run the script and define the runtime information for the parent table

Verify the DVM Configuration is valid (utilizes DVM QC configuration views)
	Run the example on test category 7

Develop the repeatable test cases to verify the DVM validation criteria are working properly (develop a test data set with specific validation issue instances so they can be identified with the DVM)
	This was developed using the CCD (look at the documentation briefly to show the different automated test case categories - uses a diff tool to verify the expected results match the actual results)
	Won't go into this in detail, but when we meet to install/configure it we will dive into the details more

	** Most of these test case categories were developed specifically to verify that the core code of the DVM is working properly, you won't probably need more than a couple depending on the complexity of your test cases

Show how it was implemented in the cruise DB:
	DVM package call is "wrapped" in cruise-specific procedures: one for executing on a given cruise ID, one for a given cruise name, one that executes on all cruise records in batch
		one special procedure that identifies overlap and automatically executes the DVM on the overlapping parent records (this handles the case where one parent record is updated and that causes a conflict with another parent record if this was not implemented then the other parent record would not show that it had an overlap issue
			This is the one that has been implemented in the Cruise APEX app to automatically execute when the parent record or related child records are updated
	So there is quite a bit of flexibility in how you implement it

Look at the cruise APEX interface to show how the DVM has been integrated and allow annotation of validation issues
	Look at Cruise List (DVM columns)
	Look at View/Edit Cruise page (summary pane has DVM info and DVM tab)
		Update the cruise name to resolve the issue and note how the validation issue disappears from the list on update action
	Look at View/Edit Cruise Leg page (summary pane has DVM info)

Show an example of the DVM executing when the cruise name is updated

4 Standard Reports (test case category 6):
	Show the examples:
		DVM_RULE_SETS_RPT_V (all validation rule sets used over time)
		CCD_CRUISE_DVM_RULES_RPT_V (specific data quality control criteria that was used to validate each cruise record)
		CCD_CRUISE_DVM_EVAL_RPT_V (DVM rule set evaluation history for each cruise record)
		CCD_CRUISE_DVM_RULE_EVAL_RPT_V (provide information about each time the DVM was evaluated for which specific validation rules on a given cruise for each data stream if that level of detail is desired)

	3 of which are data set specific and require minimal development as the DVM portion of the information is readily available



There is more but I figured this is probably already more than we had time to review

Thank you for participating, does anyone have any questions?

/*********************/
(Later Sessions:)
/*********************/
Demo the test cases and how to verify they are working properly (PICD)

Demo the test cases and how to verify they are working properly

Demo the Cruise DB is validated each time a cruise/cruise leg is saved

Cruise/Leg Overlap functionality (validates the new ones or re-validates after the leg is deleted)


Configuration QC features



VCM
	show how the database upgrade files are organized and named
	show how the combined upgrade file works



Lessons learned:
	user defined exceptions
	robust error handling
	query optimization (data dictionary queries are very slow)
		indexed numeric keys work well for joining data quickly
	Business rules defined in one central place is very useful, can easily refer to the specific business rule IDs in other related documents
